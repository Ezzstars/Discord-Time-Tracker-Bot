import os
import sqlite3
from datetime import datetime, timezone, timedelta, time as dtime
import logging
import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from discord import app_commands
from dotenv import load_dotenv
import pandas as pd

# ---------------- BASIC SETUP ----------------
logging.basicConfig(level=logging.INFO)
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

# Replace these with your actual channel IDs
BUTTONS_CHANNEL_ID = 111111111111111111  # Channel where buttons appear
TIMING_CHANNEL_ID = 222222222222222222   # Channel where session logs are posted
REPORTS_CHANNEL_ID = 333333333333333333  # Channel where weekly reports upload

intents = discord.Intents.default()
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree

DB_FILE = "work_sessions.db"

# ---------------- DATABASE ----------------
def db_conn():
    return sqlite3.connect(DB_FILE)

def init_db():
    conn = db_conn()
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS sessions(
        user_id TEXT PRIMARY KEY,
        name TEXT,
        start_time TEXT,
        message_id INTEGER,
        dm_warned INTEGER DEFAULT 0
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS totals(
        user_id TEXT PRIMARY KEY,
        name TEXT,
        total_seconds REAL
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS history(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT,
        name TEXT,
        start_time TEXT,
        end_time TEXT,
        duration_seconds REAL,
        penalty_applied INTEGER DEFAULT 0
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS meta(
        key TEXT PRIMARY KEY,
        value TEXT
    )""")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('max_session_hours','5')")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('penalty_tokens','20000')")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('reminder_minutes','30')")
    conn.commit()
    conn.close()

init_db()

# ---------------- UTILITIES ----------------
def get_meta(key: str, default: str) -> str:
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT value FROM meta WHERE key=?", (key,))
    row = c.fetchone()
    conn.close()
    return row[0] if row else default

def set_meta(key: str, value: str):
    conn = db_conn(); c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO meta(key,value) VALUES(?,?)", (key, str(value)))
    conn.commit(); conn.close()

def ordinal(n: int) -> str:
    return "%d%s" % (n, "tsnrhtdd"[(n // 10 % 10 != 1) * (n % 10 < 4) * n % 10 :: 4])

def fmt_time_12(dt: datetime) -> str:
    return dt.astimezone().strftime("%I:%M %p").lstrip("0")

def fmt_date_paren(dt: datetime) -> str:
    local = dt.astimezone()
    return f"({ordinal(local.day)} {local.strftime('%b %Y')})"

def pretty_hm(seconds: float) -> str:
    seconds = int(seconds)
    h, r = divmod(seconds, 3600)
    m, _ = divmod(r, 60)
    return f"{h} h {m} m"

def get_channel(cid: int):
    return bot.get_channel(cid)

def get_limit_hours() -> int:
    return int(get_meta("max_session_hours", "5"))

def get_penalty_tokens() -> int:
    return int(get_meta("penalty_tokens", "20000"))

def get_reminder_minutes() -> int:
    return int(get_meta("reminder_minutes", "30"))

# ---------------- BUTTONS ----------------
class TimeButtons(View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Check In", emoji="üü¢", style=discord.ButtonStyle.success, custom_id="time_checkin")
    async def check_in(self, interaction: discord.Interaction, _: Button):
        user_id = str(interaction.user.id)
        name = interaction.user.display_name
        conn = db_conn(); c = conn.cursor()

        c.execute("SELECT 1 FROM sessions WHERE user_id=?", (user_id,))
        if c.fetchone():
            await interaction.response.send_message("‚ö†Ô∏è You‚Äôre already checked in.", ephemeral=True)
            conn.close(); return

        timing_ch = get_channel(TIMING_CHANNEL_ID)
        if not timing_ch:
            await interaction.response.send_message("‚ùå Timing channel not found.", ephemeral=True)
            conn.close(); return

        now = datetime.now(timezone.utc)
        msg = await timing_ch.send(
            f"üßë Name: {interaction.user.mention}\n"
            f"‚úÖ Check in: {fmt_time_12(now)} {fmt_date_paren(now)}"
        )

        c.execute("INSERT OR REPLACE INTO sessions(user_id,name,start_time,message_id,dm_warned) VALUES(?,?,?,?,0)",
                  (user_id, name, now.isoformat(), msg.id))
        conn.commit(); conn.close()
        await interaction.response.send_message("‚úÖ Checked in!", ephemeral=True)

    @discord.ui.button(label="Check Out", emoji="üî¥", style=discord.ButtonStyle.danger, custom_id="time_checkout")
    async def check_out(self, interaction: discord.Interaction, _: Button):
        user_id = str(interaction.user.id)
        name = interaction.user.display_name
        conn = db_conn(); c = conn.cursor()
        c.execute("SELECT start_time,message_id FROM sessions WHERE user_id=?", (user_id,))
        row = c.fetchone()

        if not row:
            await interaction.response.send_message("‚ö†Ô∏è You haven‚Äôt checked in.", ephemeral=True)
            conn.close(); return

        start_iso, message_id = row
        start_dt = datetime.fromisoformat(start_iso)
        end_dt = datetime.now(timezone.utc)
        duration = (end_dt - start_dt).total_seconds()
        limit_h = get_limit_hours(); penalty_t = get_penalty_tokens()

        timing_ch = get_channel(TIMING_CHANNEL_ID)
        msg = await timing_ch.fetch_message(message_id)

        capped_seconds = limit_h * 3600
        penalized = 0

        if duration > capped_seconds:
            duration = capped_seconds
            penalized = 1
            content = (
                f"üßë Name: {interaction.user.mention}\n"
                f"‚úÖ Check in: {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                f"‚ö†Ô∏è Warning: auto-checked out after {limit_h} hours.\n"
                f"üíÄ Penalty: {penalty_t:,} SPCA sent to burn wallet.\n"
                f"üí° Session counted: {pretty_hm(duration)}"
            )
        else:
            content = (
                f"üßë Name: {interaction.user.mention}\n"
                f"‚úÖ Check in: {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                f"üî¥ Check out: {fmt_time_12(end_dt)}\n"
                f"üí° Session: {pretty_hm(duration)}"
            )

        # update totals
        c.execute("DELETE FROM sessions WHERE user_id=?", (user_id,))
        c.execute("SELECT total_seconds FROM totals WHERE user_id=?", (user_id,))
        prev = c.fetchone()
        new_total = duration + (prev[0] if prev else 0)
        c.execute("INSERT OR REPLACE INTO totals(user_id,name,total_seconds) VALUES(?,?,?)",
                  (user_id, name, new_total))
        c.execute("""INSERT INTO history(user_id,name,start_time,end_time,duration_seconds,penalty_applied)
                     VALUES(?,?,?,?,?,?)""",
                  (user_id, name, start_dt.isoformat(), end_dt.isoformat(), duration, penalized))
        conn.commit(); conn.close()

        await msg.edit(content=content)
        await interaction.response.send_message("‚úÖ Session saved!", ephemeral=True)

# ---------------- AUTO CHECKER WITH DM REMINDER ----------------
@tasks.loop(minutes=5)
async def monitor_sessions():
    limit_h = get_limit_hours()
    penalty_t = get_penalty_tokens()
    reminder_m = get_reminder_minutes()
    now = datetime.now(timezone.utc)

    conn = db_conn()
    c = conn.cursor()
    c.execute("SELECT user_id, name, start_time, message_id, dm_warned FROM sessions")
    rows = c.fetchall()

    for user_id, name, start_iso, msg_id, dm_warned in rows:
        start_dt = datetime.fromisoformat(start_iso)
        elapsed = (now - start_dt).total_seconds()
        warn_time = (limit_h * 3600) - (reminder_m * 60)

        # DM Reminder before auto-checkout
        if elapsed >= warn_time and not dm_warned:
            try:
                user = await bot.fetch_user(int(user_id))
                remaining = (limit_h * 3600) - elapsed
                rem_h, rem_m = divmod(int(remaining // 60), 60)
                rem_text = f"{rem_h}h {rem_m}m" if rem_h > 0 else f"{rem_m}m"

                reminder_msg = (
                    f"‚è∞ **Hey {user.mention}!**\n"
                    f"You‚Äôve been clocked in for **{pretty_hm(elapsed)}**.\n"
                    f"You have **{rem_text} left** before auto-checkout will apply a **{penalty_t:,} SPCA** penalty.\n\n"
                    f"üìç **Check-out channel:** <#{BUTTONS_CHANNEL_ID}>\n"
                    f"üè¢ **Server:** *Ezzstar Office*\n\n"
                    f"Please **check out soon** to avoid the penalty."
                )

                await user.send(reminder_msg)
                c.execute("UPDATE sessions SET dm_warned = 1 WHERE user_id = ?", (user_id,))
                conn.commit()
                logging.info(f"‚úÖ Sent DM reminder to {name} ({user_id})")
            except Exception as e:
                logging.warning(f"‚ö†Ô∏è Failed to DM {user_id}: {e}")

        # Auto-checkout after limit
        if elapsed >= limit_h * 3600:
            c.execute("DELETE FROM sessions WHERE user_id=?", (user_id,))
            c.execute("SELECT total_seconds FROM totals WHERE user_id=?", (user_id,))
            prev = c.fetchone()
            new_total = limit_h * 3600 + (prev[0] if prev else 0)

            c.execute("INSERT OR REPLACE INTO totals(user_id,name,total_seconds) VALUES(?,?,?)",
                      (user_id, name, new_total))
            c.execute("""INSERT INTO history(user_id,name,start_time,end_time,duration_seconds,penalty_applied)
                         VALUES(?,?,?,?,?,1)""",
                      (user_id, name, start_dt.isoformat(), now.isoformat(), limit_h * 3600, 1))
            conn.commit()

            ch = get_channel(TIMING_CHANNEL_ID)
            try:
                msg = await ch.fetch_message(msg_id)
                content = (
                    f"üßë Name: <@{user_id}>\n"
                    f"‚úÖ Check in: {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                    f"‚ö†Ô∏è Warning: auto-checked out after {limit_h} hours.\n"
                    f"üíÄ Penalty: {penalty_t:,} SPCA sent to burn wallet.\n"
                    f"üí° Session counted: {pretty_hm(limit_h * 3600)}"
                )
                await msg.edit(content=content)
            except Exception as e:
                logging.warning(f"Edit failed: {e}")
    conn.close()

# ---------------- WEEKLY REPORT ----------------
@tasks.loop(time=dtime(hour=23, minute=59))
async def weekly_report():
    if datetime.now().weekday() != 6:
        return
    end = datetime.now(timezone.utc); start = end - timedelta(days=7)
    conn = db_conn(); c = conn.cursor()
    c.execute("""SELECT name,SUM(duration_seconds) FROM history
                 WHERE end_time BETWEEN ? AND ? GROUP BY name""", (start.isoformat(), end.isoformat()))
    totals = c.fetchall()
    c.execute("""SELECT name,COUNT(*) FROM history
                 WHERE penalty_applied=1 AND end_time BETWEEN ? AND ? GROUP BY name""",
              (start.isoformat(), end.isoformat()))
    penalized = dict(c.fetchall()); conn.close()

    rows = []
    for name, secs in totals:
        rows.append({
            "Name": name,
            "Total Hours (last 7 days)": round(secs / 3600, 2),
            "Penalized Sessions": penalized.get(name, 0)
        })

    if not rows:
        rows = [{"Name": "No sessions", "Total Hours (last 7 days)": 0, "Penalized Sessions": 0}]
    df = pd.DataFrame(rows)
    fname = f"weekly_summary_{datetime.now().strftime('%Y_%m_%d')}.xlsx"
    df.to_excel(fname, index=False)
    ch = get_channel(REPORTS_CHANNEL_ID)
    if ch:
        await ch.send(content="üìä Weekly Summary", file=discord.File(fname))

# ---------------- SLASH COMMANDS ----------------
@tree.command(name="post_buttons", description="Post Check In/Out buttons")
async def post_buttons(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚ùå Admins only.", ephemeral=True); return
    if interaction.channel_id != BUTTONS_CHANNEL_ID:
        await interaction.response.send_message("‚ö†Ô∏è Use this in the buttons channel.", ephemeral=True); return
    await interaction.channel.send("üïí Click below to Check In / Check Out", view=TimeButtons())
    await interaction.response.send_message("‚úÖ Buttons posted!", ephemeral=True)

@tree.command(name="update_limit", description="Admin: update session hours, penalty, or reminder.")
@app_commands.describe(hours="Max hours", penalty="Penalty SPCA", reminder="Minutes before auto-checkout to DM reminder")
async def update_limit(interaction: discord.Interaction, hours: int, penalty: int, reminder: int):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚ùå Admins only.", ephemeral=True); return
    if hours < 1 or hours > 24:
        await interaction.response.send_message("‚ö†Ô∏è Hours must be 1‚Äì24.", ephemeral=True); return
    if reminder < 5 or reminder > (hours * 60):
        await interaction.response.send_message("‚ö†Ô∏è Reminder must be within session time.", ephemeral=True); return

    set_meta("max_session_hours", str(hours))
    set_meta("penalty_tokens", str(penalty))
    set_meta("reminder_minutes", str(reminder))
    await interaction.response.send_message(
        f"‚úÖ Limit set to {hours}h, penalty {penalty:,} SPCA, reminder {reminder} minutes before auto-checkout.",
        ephemeral=True
    )

# ---------------- READY EVENT ----------------
@bot.event
async def on_ready():
    bot.add_view(TimeButtons())
    synced = await tree.sync()
    print(f"‚úÖ Logged in as {bot.user} | Synced {len(synced)} commands")
    monitor_sessions.start()
    weekly_report.start()

bot.run(TOKEN)
