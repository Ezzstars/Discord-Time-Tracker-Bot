import os
import sqlite3
from datetime import datetime, timezone, timedelta, time as dtime
import logging
import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from discord import app_commands
from dotenv import load_dotenv
import pandas as pd

# ---------------- BASIC SETUP ----------------
logging.basicConfig(level=logging.INFO)
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

BUTTONS_CHANNEL_ID = 1435012162128183408
TIMING_CHANNEL_ID = 1203395497843228763
REPORTS_CHANNEL_ID = 1435037114797654136

intents = discord.Intents.default()
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree
DB_FILE = "work_sessions.db"

# ---------------- DATABASE ----------------
def db_conn():
    return sqlite3.connect(DB_FILE)

def init_db():
    conn = db_conn()
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS sessions(
        user_id TEXT PRIMARY KEY,
        name TEXT,
        start_time TEXT,
        message_id INTEGER,
        dm_warned INTEGER DEFAULT 0
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS totals(
        user_id TEXT PRIMARY KEY,
        name TEXT,
        total_seconds REAL
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS history(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT,
        name TEXT,
        start_time TEXT,
        end_time TEXT,
        duration_seconds REAL,
        penalty_applied INTEGER DEFAULT 0
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS meta(
        key TEXT PRIMARY KEY,
        value TEXT
    )""")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('max_session_hours','5')")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('penalty_tokens','20000')")
    c.execute("INSERT OR IGNORE INTO meta(key,value) VALUES('reminder_minutes','30')")
    conn.commit()
    conn.close()

init_db()

# ---------------- UTILITIES ----------------
def get_meta(key: str, default: str) -> str:
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT value FROM meta WHERE key=?", (key,))
    row = c.fetchone()
    conn.close()
    return row[0] if row else default

def set_meta(key: str, value: str):
    conn = db_conn(); c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO meta(key,value) VALUES(?,?)", (key, str(value)))
    conn.commit(); conn.close()

def fmt_time_12(dt: datetime) -> str:
    return dt.astimezone().strftime("%I:%M %p").lstrip("0")

def fmt_date_paren(dt: datetime) -> str:
    local = dt.astimezone()
    return f"({local.strftime('%d %b %Y')})"

def pretty_hm(seconds: float) -> str:
    seconds = int(seconds)
    h, r = divmod(seconds, 3600)
    m, _ = divmod(r, 60)
    return f"{h} h {m} m"

def get_channel(cid: int):
    return bot.get_channel(cid)

def get_limit_hours() -> int:
    return int(get_meta("max_session_hours", "5"))

def get_penalty_tokens() -> int:
    return int(get_meta("penalty_tokens", "20000"))

def get_reminder_minutes() -> int:
    return int(get_meta("reminder_minutes", "30"))

# ---------------- BUTTONS ----------------
class TimeButtons(View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Check In", emoji="üü¢", style=discord.ButtonStyle.success, custom_id="time_checkin")
    async def check_in(self, interaction: discord.Interaction, _: Button):
        user_id = str(interaction.user.id)
        name = interaction.user.display_name
        conn = db_conn(); c = conn.cursor()

        c.execute("SELECT 1 FROM sessions WHERE user_id=?", (user_id,))
        if c.fetchone():
            await interaction.response.send_message("‚ö†Ô∏è You‚Äôre already checked in.", ephemeral=True)
            conn.close(); return

        timing_ch = get_channel(TIMING_CHANNEL_ID)
        if not timing_ch:
            await interaction.response.send_message("‚ùå Timing channel not found.", ephemeral=True)
            conn.close(); return

        now = datetime.now(timezone.utc)
        embed = discord.Embed(color=discord.Color.green())
        embed.add_field(name="üßë Name", value=interaction.user.mention, inline=False)
        embed.add_field(name="‚úÖ Check in", value=f"{fmt_time_12(now)} {fmt_date_paren(now)}", inline=False)
        embed.set_footer(text="Session started")

        msg = await timing_ch.send(embed=embed)
        c.execute("INSERT OR REPLACE INTO sessions(user_id,name,start_time,message_id,dm_warned) VALUES(?,?,?,?,0)",
                  (user_id, name, now.isoformat(), msg.id))
        conn.commit(); conn.close()
        await interaction.response.send_message("‚úÖ Checked in!", ephemeral=True)

    @discord.ui.button(label="Check Out", emoji="üî¥", style=discord.ButtonStyle.danger, custom_id="time_checkout")
    async def check_out(self, interaction: discord.Interaction, _: Button):
        user_id = str(interaction.user.id)
        name = interaction.user.display_name
        conn = db_conn(); c = conn.cursor()
        c.execute("SELECT start_time,message_id FROM sessions WHERE user_id=?", (user_id,))
        row = c.fetchone()

        if not row:
            await interaction.response.send_message("‚ö†Ô∏è You haven‚Äôt checked in.", ephemeral=True)
            conn.close(); return

        start_iso, message_id = row
        start_dt = datetime.fromisoformat(start_iso)
        end_dt = datetime.now(timezone.utc)
        duration = (end_dt - start_dt).total_seconds()
        limit_h = get_limit_hours(); penalty_t = get_penalty_tokens()
        capped_seconds = limit_h * 3600
        penalized = 0

        timing_ch = get_channel(TIMING_CHANNEL_ID)
        msg = await timing_ch.fetch_message(message_id)

        if duration > capped_seconds:
            duration = capped_seconds
            penalized = 1
            embed = discord.Embed(color=discord.Color.yellow())
            embed.add_field(name="", value=(
                f"üßë **Name:** {interaction.user.mention}\n"
                f"‚úÖ **Check in:** {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                f"‚ö†Ô∏è **Warning:** Auto-checkout after {limit_h}h.\n"
                f"üíÄ **Penalty:** {penalty_t:,} SPCA sent to burn wallet.\n"
                f"üí° **Counted:** {pretty_hm(duration)}"
            ), inline=False)
        else:
            embed = discord.Embed(color=discord.Color.red())
            embed.add_field(name="", value=(
                f"üßë **Name:** {interaction.user.mention}\n"
                f"‚úÖ **Check in:** {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                f"üî¥ **Check out:** {fmt_time_12(end_dt)}\n"
                f"üí° **Session:** {pretty_hm(duration)}"
            ), inline=False)

        # update DB
        c.execute("DELETE FROM sessions WHERE user_id=?", (user_id,))
        c.execute("SELECT total_seconds FROM totals WHERE user_id=?", (user_id,))
        prev = c.fetchone()
        new_total = duration + (prev[0] if prev else 0)
        c.execute("INSERT OR REPLACE INTO totals(user_id,name,total_seconds) VALUES(?,?,?)",
                  (user_id, name, new_total))
        c.execute("""INSERT INTO history(user_id,name,start_time,end_time,duration_seconds,penalty_applied)
                     VALUES(?,?,?,?,?,?)""",
                  (user_id, name, start_dt.isoformat(), end_dt.isoformat(), duration, penalized))
        conn.commit(); conn.close()

        await msg.edit(embed=embed)
        await interaction.response.send_message("‚úÖ Session saved!", ephemeral=True)

# ---------------- AUTO CHECKER ----------------
@tasks.loop(minutes=5)
async def monitor_sessions():
    limit_h = get_limit_hours()
    penalty_t = get_penalty_tokens()
    reminder_m = get_reminder_minutes()
    now = datetime.now(timezone.utc)

    conn = db_conn()
    c = conn.cursor()
    c.execute("SELECT user_id, name, start_time, message_id, dm_warned FROM sessions")
    rows = c.fetchall()

    for user_id, name, start_iso, msg_id, dm_warned in rows:
        start_dt = datetime.fromisoformat(start_iso)
        elapsed = (now - start_dt).total_seconds()
        warn_time = (limit_h * 3600) - (reminder_m * 60)

        # DM Reminder
        if elapsed >= warn_time and not dm_warned:
            try:
                user = await bot.fetch_user(int(user_id))
                await user.send(
                    f"‚è∞ **Hey {user.name}!**\n"
                    f"You‚Äôve been clocked in for **{pretty_hm(elapsed)}**.\n"
                    f"You have **{reminder_m}m left** before auto-checkout applies a **{penalty_t:,} SPCA** penalty.\n\n"
                    f"üìç **Check-out channel:** <#{BUTTONS_CHANNEL_ID}>\n"
                    f"üè¢ **Server:** Ezzstar Office"
                )
                c.execute("UPDATE sessions SET dm_warned = 1 WHERE user_id=?", (user_id,))
                conn.commit()
            except Exception as e:
                logging.warning(f"DM failed for {user_id}: {e}")

        # Auto-checkout
        if elapsed >= limit_h * 3600:
            c.execute("DELETE FROM sessions WHERE user_id=?", (user_id,))
            c.execute("SELECT total_seconds FROM totals WHERE user_id=?", (user_id,))
            prev = c.fetchone()
            new_total = limit_h * 3600 + (prev[0] if prev else 0)
            c.execute("INSERT OR REPLACE INTO totals(user_id,name,total_seconds) VALUES(?,?,?)",
                      (user_id, name, new_total))
            c.execute("""INSERT INTO history(user_id,name,start_time,end_time,duration_seconds,penalty_applied)
                         VALUES(?,?,?,?,?,1)""",
                      (user_id, name, start_dt.isoformat(), now.isoformat(), limit_h * 3600, 1))
            conn.commit()

            ch = get_channel(TIMING_CHANNEL_ID)
            try:
                msg = await ch.fetch_message(msg_id)
                embed = discord.Embed(color=discord.Color.yellow())
                embed.add_field(name="", value=(
                    f"üßë **Name:** <@{user_id}>\n"
                    f"‚úÖ **Check in:** {fmt_time_12(start_dt)} {fmt_date_paren(start_dt)}\n"
                    f"‚ö†Ô∏è **Warning:** Auto-checkout after {limit_h}h.\n"
                    f"üíÄ **Penalty:** {penalty_t:,} SPCA sent to burn wallet.\n"
                    f"üí° **Counted:** {limit_h} h 0 m"
                ), inline=False)
                await msg.edit(embed=embed)
            except Exception as e:
                logging.warning(f"Edit failed: {e}")
    conn.close()

# ---------------- WEEKLY REPORT ----------------
@tasks.loop(time=dtime(hour=0, minute=0))
async def weekly_report():
    if datetime.now().weekday() != 6:
        return
    end = datetime.now(timezone.utc); start = end - timedelta(days=7)
    conn = db_conn(); c = conn.cursor()
    c.execute("""SELECT name,SUM(duration_seconds) FROM history
                 WHERE end_time BETWEEN ? AND ? GROUP BY name""", (start.isoformat(), end.isoformat()))
    totals = c.fetchall()
    c.execute("""SELECT name,COUNT(*) FROM history
                 WHERE penalty_applied=1 AND end_time BETWEEN ? AND ? GROUP BY name""",
              (start.isoformat(), end.isoformat()))
    penalized = dict(c.fetchall()); conn.close()

    if not totals:
        return

    sorted_data = sorted(totals, key=lambda x: x[1], reverse=True)
    embed = discord.Embed(title="üèÜ Weekly Leaderboard üèÜ", color=discord.Color.gold())

    for i, (name, secs) in enumerate(sorted_data[:3]):
        rank = ["ü•á", "ü•à", "ü•â"][i] if i < 3 else f"#{i+1}"
        embed.add_field(
            name=f"{rank} {name}",
            value=f"üß≠ Total time: {pretty_hm(secs)}\n‚ö†Ô∏è Penalties: {penalized.get(name, 0)}",
            inline=False
        )

    df = pd.DataFrame([{
        "Name": n,
        "Total Hours": round(s / 3600, 2),
        "Penalties": penalized.get(n, 0)
    } for n, s in totals])
    fname = f"weekly_summary_{datetime.now().strftime('%Y_%m_%d')}.xlsx"
    df.to_excel(fname, index=False)
    ch = get_channel(REPORTS_CHANNEL_ID)
    await ch.send(embed=embed, file=discord.File(fname))

# ---------------- COMMANDS ----------------
@tree.command(name="post_buttons", description="Post Check In/Out buttons")
async def post_buttons(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚ùå Admin only.", ephemeral=True); return
    await interaction.channel.send("üïí Click below to Check In / Check Out", view=TimeButtons())
    await interaction.response.send_message("‚úÖ Buttons posted!", ephemeral=True)

@tree.command(name="update_limit", description="Admin: update session limits, penalty, reminder")
async def update_limit(interaction: discord.Interaction, hours: int, penalty: int, reminder: int):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚ùå Admin only.", ephemeral=True); return
    set_meta("max_session_hours", str(hours))
    set_meta("penalty_tokens", str(penalty))
    set_meta("reminder_minutes", str(reminder))
    await interaction.response.send_message(
        f"‚úÖ Updated: Limit {hours}h, Penalty {penalty:,} SPCA, Reminder {reminder}m before auto-checkout.",
        ephemeral=True
    )

# ---------------- READY EVENT ----------------
@bot.event
async def on_ready():
    bot.add_view(TimeButtons())
    await tree.sync()
    print(f"‚úÖ Logged in as {bot.user}")
    monitor_sessions.start()
    weekly_report.start()

bot.run(TOKEN)
